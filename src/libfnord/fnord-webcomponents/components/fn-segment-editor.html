<!--
  This file is part of the "FnordMetric" project
    Copyright (c) 2015 Laura Schlimmer
    Copyright (c) 2015 Paul Asmuth

  FnordMetric is free software: you can redistribute it and/or modify it under
  the terms of the GNU General Public License v3.0. You should have received a
  copy of the GNU General Public License along with this program. If not, see
  <http://www.gnu.org/licenses/>.
-->

<template id="fn-segment-editor-base-tpl">
  <fn-loader class='segment-editor-loader'>
    <fn-segment-editor-field class='segment-clickable' class='icon' data-action='open-segment-editor' >
      <i class='fa fa-filter'></i>
      <fn-segment-editor-field-values></fn-segment-editor-field-values>
      <fn-segment-open-icon class='segment-clickable' data-action='open-segment-editor'>
      </fn-segment-open-icon>
    </fn-segment-editor-field>
  </fn-loader>

  <!-- View: Segments -->
  <fn-segment-flyout>
    <fn-segment-header>Segments</fn-segment-header>

    <fn-segments></fn-segments>

    <fn-tooltip data-name='remove'>Delete Segment</fn-tooltip>

    <fn-segment-footer>
      <fn-button data-action='add-segment'>Add Segment</fn-button>
    </fn-segment-footer>
  </fn-segment-flyout>

  <fn-modal-dimmer>
    <fn-modal class='segment-editor'>
      <fn-modal-close-icon></fn-modal-close-icon>

      <!-- View: Recent Segments -->
      <fn-segment-recent>
        <fn-segment-header>
          <fn-segment-header-title>Recent Segments</fn-segment-header-title>
          <fn-button data-action='segment-select'>
            <i class='fa fa-plus'></i> New Segment
          </fn-button>
        </fn-segment-header>

        <fn-loader name='recent_segments' data-loading>
          <fn-segments></fn-segments>
        </fn-loader>

        <fn-tooltip data-name='add'>Add to Segments</fn-tooltip>
        <fn-tooltip data-name='remove'>Remove This Segment</fn-tooltip>

        <template name='fn-segments-empty'>
          <fn-segments-empty>
            <div class='segment-text'>No Segments Found</div>
            <div class='segment-link'>Add a new Segment</div>
          </fn-segments-empty>
        </template>

        <fn-segment-footer>
          <fn-button data-action='delete-selected'>
            <i class='fa fa-trash-o'></i> Remove Selected
          </fn-button>
          <fn-button data-action='add-selected'>
            <i class='fa fa-plus'></i> Add Selected
          </fn-button>
        </fn-segment-footer>
      </fn-segment-recent>


      <!-- View: Create New Segment -->
      <fn-segment-select>
      </fn-segment-select>

      <template name='fn-segment-select'>
        <fn-segment-select>
          <fn-segment-header>
            <input class='fn-input' placeholder='Segment Name' data-segment-name />
            <fn-segment-error-message name='name'>Please insert a (unique) name</fn-segment-error-message>
            <fn-segment-error-message name='option'>Please select at least one option</fn-segment-error-message>

            <fn-button data-action='cancel-segment'>Cancel</fn-button>
            <fn-button data-action='save-segment'>Save</fn-button>
          </fn-segment-header>

          <fn-segment-options></fn-segment-options>
        </fn-segment-select>
      </template>


      <!-- View: Edit Exisiting Segment -->
      <fn-segment-edit>
        <fn-segment-header>
          <input class='fn-input' data-segment-name />
          <fn-segment-error-message>Please insert a name</fn-segment-error-message>

          <fn-button data-action='cancel-segment'>Cancel</fn-button>
          <fn-button data-action='replace-segment'>Save</fn-button>
        </fn-segment-header>

        <fn-segment-error-message>
          Please select at least one option
        </fn-segment-error-message>

        <fn-segment-options></fn-segment-options>

      </fn-segment-edit>


    </fn-modal>
  </fn-modal-dimmer>
</template>

<script type='text/javascript'>
  var SegmentEditor = function() {
    this.createdCallback = function() {
      var tpl = Fnord.getTemplate("fn-segment-editor", "base");
      this.appendChild(tpl);

      if (this.hasAttribute('data-resolved')) {
        this.init();
      }

      if (this.hasAttribute('data-loading')) {
        this.querySelector("fn-loader").setAttribute('data-loading', 'loading');
      }

    };

    this.attributeChangedCallback = function(attr, old_val, new_val) {
      if (attr == 'data-resolved' && new_val == 'resolved') {
        this.querySelector("fn-loader").removeAttribute('data-loading');
        return this.init();
      }
      if (attr == 'data-loading' && new_val == null) {
        this.querySelector("fn-loader").removeAttribute('data-loading');
        return this.init();
      }
    };

    this.onDocumentClick = function() {
      this.closeFlyout();
    }


    this.init = function() {
      var _this = this;

      this.querySelector(
        "[data-action='open-segment-editor']").onclick = function(e) {
          e.stopPropagation();
          _this.showFlyout();
      }

      if (this.hasAttribute('data-segments')) {
        this.renderSegments();
        this.renderPreviewValues();
      }

      this.querySelector("fn-segment-select").onclick = function() {
        _this.closeActiveItems.bind(this)();
      }

      this.querySelector("fn-segment-edit").onclick = function() {
        _this.closeActiveItems.bind(this)();
      }

      this.renderSegmentOptions();
      this.handleViewVisibility();
    };


    /**
      * Close open Items (e.g. dropdowns) on editor click
      */
    this.closeActiveItems = function() {
      var active_items = this.querySelectorAll("[data-active]");

      for (var i = 0; i < active_items.length; i++) {
        if (typeof active_items[i].onDocumentClick == 'function') {
          active_items[i].onDocumentClick();
        }
      }
    };

    /**
      * Indicates whether the segment is removable or not
      */
    this.isRemovable = function(segment) {
      return true;
    };

    /**
      * Indicates whether the segment is editable or not
      */
    this.isEditable = function(segment) {
      return true;
    };


    /**
      * Get a color for a new segment
      * NOTE: you may want to set this.availableColors to customise the colors
      */
    this.getSegmentColor = function(segment) {
      var index = JSON.parse(this.getAttribute('data-segments')).length;

      if (!this.availableColors || this.availableColors.constructor !== Array) {
        this.availableColors = ["#4572a7", "#aa4643", "#89a54e", "#80699b"];
      }

      return this.availableColors[index % this.availableColors.length];
    };

    this.segmentNameExists = function(name) {
      var segments = JSON.parse(this.getAttribute('data-segments'));

      for (var i = 0; i < segments.length; i++) {
        if (segments[i].name == name) {
          return true;
        }
      }

      return false;
    }

    /**
      * Checks if the segment has a name and at least one option
      * Marks missing elements
      *
      * @return {boolean}
      */
    this.validateSegment = function(segment, isNew) {
      var valid = true;

      if (segment.name.length == 0 || (isNew && this.segmentNameExists(segment.name))) {
        valid = false;
        this.querySelector(".segment-active fn-segment-error-message[name='name']")
          .classList.add("segment-error");
      }

      if (segment.rules.length > 0) {
        for (var i = 0; i < segment.rules.length; i++) {
          var s = segment.rules[i];

          if (s.field.length == 0 || s.values[0].length == 0) {
            valid = false;

            //FIXME proper error message text
            this.querySelector(".segment-active fn-segment-error-message[name='option']")
              .classList.add("segment-error");
            break;
          }
        };
      } else {
        valid = false;
        this.querySelector(".segment-active fn-segment-error-message[name='option']")
          .classList.add("segment-error");
      }

      return valid;
    };


    this.removeErrorMessages = function() {
      var errors = this.querySelectorAll(".segment-error");

      for (var i = 0; i < errors.length; i++) {
        errors[i].classList.remove("segment-error");
      }
    };

    this.getSegmentKey = function(name) {
      return name.toLowerCase().replace(/\s/g, "_");
    }

    /**
      * Collects the segment parameters from the html elements
      *
      * @param {object HTMLElement} fn_segment
      * @return {object} segment
      * @return {string} segment.key The key of the segment
      * @return {string} segment.name The name of the segment
      * @return {Array[object]} segment.rules The selected options
      * @return {string} segment.rules.field The rule field name
      * @return {string} segment.rules.op The rule option (=matches)
      * @return {Array[string]} segment.rules.values The rule values
      * @return {boolean} segment.removable
      * @return {boolean} segment.editable
      * @return {string} segment.color The segments hex or rgb(a) color
      */
    this.getSegmentSelection = function(fn_segment) {
      var options = fn_segment.querySelectorAll("fn-segment-option");
      var name = fn_segment.querySelector("input[data-segment-name]").value;

      var segment = {
        'key' : this.getSegmentKey(name),
        'name' : name,
        'rules' : []
      };

      for (var i = 0; i < options.length; i++) {
        //is not selected
        if (!options[i].querySelector("fn-checkbox").hasAttribute('data-active')) {
          continue;
        }

        var option_elems = options[i].querySelectorAll("[data-segment-option]");
        var type = options[i].getAttribute('data-type');
        var opt = (type == null || type == 'string') ? 'matches' : 'matches_uint32';
        var values = [];

        for (var j = 0; j < option_elems.length; j++) {
          //rule option
          if (option_elems[j].hasAttribute('data-rule-opt')) {
            opt = option_elems[j].getValue();

          //rule values
          } else {
            //dropdown values are returned as csv
            if (option_elems[j].tagName == 'FN-DROPDOWN') {
              values = values.concat(option_elems[j].getValue().split(","));
            } else {
              values.push(option_elems[j].getValue());
            }
          }
        }

        segment.rules.push({
          'field' : options[i].getAttribute('data-key'),
          'op' : opt,
          'values' : values
        });
      }

      /*segment.removable = this.isRemovable(segment);
      segment.editable = this.isEditable(segment);*/
      segment.color = this.getSegmentColor(segment);

      return segment;
    };


    /******************************** Save ********************************/

    this.addNewSegment = function(segment, recent) {
      var segments = JSON.parse(this.getAttribute('data-segments'));
      var _this = this;

      //multiple new segments
      if (segment.constructor === Array) {

        segment.forEach(function(s) {
          segments.push(s);
        });

      } else {
        segments.push(segment);
      }

      this.setAttribute('data-segments', JSON.stringify(segments));

      if (recent) {
        this.fireAddRecentEvent([segment]);
      } else {
        this.fireNewSegmentEvent(segment);
      }

      this.changeView("fn-segment-flyout", false);
      this.renderSegments();
      this.renderPreviewValues();
    }

    this.onSaveSegment = function() {
      this.removeErrorMessages();

      var fn_segment_select = this.querySelector("fn-segment-select");
      var segment = this.getSegmentSelection(fn_segment_select);

      if (!this.validateSegment(segment, true)) {
        return;
      }

      this.addNewSegment(segment);
    };

    /****************************** Remove ***********************************/

    this.removeSegment = function(segment_name) {
      var segments = JSON.parse(this.getAttribute('data-segments'));

      for (var i = 0; i < segments.length; i++) {
        if (segments[i].name == segment_name) {
          segments.splice(i, 1);
        }
      }

      this.setAttribute('data-segments', JSON.stringify(segments));
      this.renderSegments();
      this.renderPreviewValues();
    };

    /******************************* Edit *************************************/

    /**
      * Edits the given segment
      *
      * @param {string} old_name edited segments (old) name
      * @param {object} segment edited segment
      */
    this.editSegment = function(old_name, segment) {
      var _this = this;
      var segments = JSON.parse(this.getAttribute('data-segments'));

      segments.forEach(function(s) {
        if (s.name == old_name) {
          s.name = segment.name;
          s.rules = segment.rules;
        }
      });

      this.setAttribute('data-segments', JSON.stringify(segments));
      this.renderSegments();
      this.renderPreviewValues();
    };

    /*********************** Render Select View *****************************/

    /**
      * Renders the fn-segment-option elements (based on the templates)
      */
    this.renderSegmentOptions = function() {
      var select_tpl = this.querySelector("template[name='fn-segment-select']");
      var fn_segment_options = select_tpl.content.querySelector("fn-segment-options");
      var tpl = this.querySelector("template[name='fn-segment-options']");

      if (tpl.content.querySelector("fn-segment-browse")) {
        return this.renderSegmentGroupOptions(tpl, fn_segment_options);
      }


      var options = tpl.content.querySelectorAll("fn-segment-option");
      var title = tpl.content.querySelector("fn-segment-options-title");
      if (title) {
        fn_segment_options.appendChild(title);
      }

      for (var i = 0; i < options.length; i++) {
        var option = this.createSegmentOption(options[i]);
        fn_segment_options.appendChild(option);
      }
    };

    /**
      * Create a fn-segment-option element (based on the template)
      */
    this.createSegmentOption = function(option) {
      var fn_segment_option = document.createElement("fn-segment-option");
      fn_segment_option.setAttribute('data-key', option.getAttribute('data-key'));
      fn_segment_option.setAttribute('data-title', option.getAttribute('data-title'));
      fn_segment_option.setAttribute('data-type', option.getAttribute('data-type'));
      var html = [
        "<div class='segment-option-cell first'><fn-checkbox></fn-checkbox><fn-segment-title>",
        option.getAttribute('data-title'),
        "</fn-segment-title></div><div class='segment-option-cell second'>",
        option.innerHTML,
        "</div>"
      ];

      fn_segment_option.innerHTML = html.join("");
      return fn_segment_option;
    }

    /**
      * Render Segment Group Menu and Segment Options
      */
    this.renderSegmentGroupOptions = function(tpl, fn_segment_options) {
      var groups = tpl.content.querySelectorAll("fn-segment-group");
      var group_menu = document.createElement("fn-menu");
      group_menu.classList.add('segment-group-menu');

      fn_segment_options.appendChild(group_menu);

      for (var i = 0; i < groups.length; i++) {
        var options = groups[i].querySelectorAll("fn-segment-option");
        var menu_item = document.createElement("fn-menu-item");
        var container = document.createElement("fn-segment-group-options");
        container.setAttribute('data-index', i);
        menu_item.setAttribute('data-index', i);
        menu_item.appendChild(groups[i].querySelector("fn-segment-group-title"));
        group_menu.appendChild(menu_item);

        var title = groups[i].querySelector("fn-segment-options-title");
        if (title) {
          container.appendChild(title);
        }

        for (var j = 0; j < options.length; j++) {
          var option = this.createSegmentOption(options[j]);
          container.appendChild(option);
        }

        fn_segment_options.appendChild(container);
      }
    };


    /**
      * Handles the group options visibility
      *
      * @param {number} index the active group's data-index attr
      * @param {object HTMLElement} segment_options
      */
    this.handleGroupOptions = function(index, segment_options) {
      var active_options =  segment_options.querySelector(
        "fn-segment-group-options[data-active]");
      var options = segment_options.querySelector(
        "fn-segment-group-options[data-index='" + index + "']");

      if (active_options) {
        active_options.removeAttribute('data-active');
      }

      options.setAttribute('data-active', 'active');
    };


    /**
      * Handles the options-group menu
      */
    this.handleGroupMenu = function(segment_options) {
      var active_group = segment_options.querySelector('fn-menu-item[data-active]');
      var active_index;
      var _this = this;

      if (!active_group) {
        active_group = segment_options.querySelector("fn-menu-item[data-index='0']");
        active_group.setAttribute('data-active', 'active');
      }

      active_index = active_group.getAttribute('data-index');
      this.handleGroupOptions(active_index, segment_options);

      segment_options.querySelector("fn-menu")
        .addEventListener('fn-menu-item-click', function(e) {
          var target = e.srcElement || e.target;
          _this.handleGroupOptions(
            target.getAttribute('data-index'), segment_options);
        },
      false);
    };

    /**
      * Renders the segments based on data-segments attribute
      */
    this.renderSegments = function() {
      var fn_segments = this.querySelector("fn-segments");
      var segments = JSON.parse(this.getAttribute('data-segments'));
      var _this = this;

      this.querySelector("fn-segments").innerHTML = "";

      segments.forEach(function(segment) {
        fn_segments.appendChild(_this.createSegment(segment));
      }, false);
    };


    /**
      * Adds a fn-segment element for each segment
      *
      * @param {string} json with segments that should be rendered
      */
    this.addSegments = function(json) {
      var segments = JSON.parse(json);
      var _this = this;
      var segments_attr = (this.hasAttribute('data-segments')) ?
        JSON.parse(this.getAttribute('data-segments')) : [];

     segments.forEach(function(segment) {
        segments_attr.push(segment);
      }, false) 

      this.renderPreviewValues(segments);
      this.setAttribute('data-segments', JSON.stringify(segments_attr));
    };

    /**
      * Return the rule's title if data-title is set for the matching
      * fn-segment-option element or the rule's key otherwise
      */
    this.getRuleTitle = function(rule_key) {
      var tpl = this.querySelector("template[name='fn-segment-options']");
      var option_elem = tpl.content.querySelector(
        "fn-segment-option[data-key='" + rule_key + "']");

      if (option_elem && option_elem.hasAttribute('data-title')) {
        return option_elem.getAttribute('data-title');
      }

      return rule_key;
    };


    this.getRuleValuePreview = function(values) {
      var value_str = "";

      if (values.length > 10) {
        return values.slice(0, 3).join(", ") + ", [ .. ], " +
          values.slice(values.length - 3).join(", ");
      }

      for (var i = 0; i < values.length; i++) {
        if (value_str.length > 20 && i + 1 != values.length) {
          value_str += ", [ .. ], " + values[values.length - 1];
          return value_str;
        }

        if ( i > 0) {
          value_str += ", ";
        }

        value_str += values[i];
      }

      return value_str;
    }


    this.getHTMLForSegmentValues = function(rules) {
      var html = [];
      var _this = this;

      rules.forEach(function(rule) {

        html.push(
          "<fn-segment-text-title>", _this.getRuleTitle(rule.field), ":",
          "</fn-segment-text-title>", "<fn-segment-text-value>",
          _this.getRuleValuePreview(rule.values),
          "</fn-segment-text-value>"
        );
      });

      return html.join("");
    };


    /**
      * Adds a fn-segment element for segment
      *
      * @param {object} segment
      */
    this.createFnSegment = function(segment, extended) {
      var fn_segment = document.createElement("fn-segment");
      var _this = this;
      var html = [];

      if (!extended) {
        html.push("<fn-segment-circle style='background: ",
          segment.color,
          ";'></fn-segment-circle>");
      }

      html.push("<fn-segment-title>", segment.name, "</fn-segment-title>");

      if (extended) {
        html.push("<fn-segment-values>",
          this.getHTMLForSegmentValues(segment.rules),
          "</fn-segment-values>");
      }

      fn_segment.innerHTML = html.join("");

      fn_segment.setAttribute('data-name', segment.name);
      fn_segment.setAttribute('data-key', segment.key);

      return fn_segment;
    };

    this.createSegment = function(segment) {
      var fn_segment = this.createFnSegment(segment, false);

      //TODO add removable/editable properties
      var icon = document.createElement("fn-segment-remove-icon");
      icon.classList.add('segment-icon');
      fn_segment.appendChild(icon);
      this.observeRemovableSegment(icon, segment.name);
      this.observeEditableSegment(fn_segment, segment);

      return fn_segment;
    }

    this.createRecentSegment = function(segment) {
      var fn_segment = this.createFnSegment(segment, true);

      var checkbox = document.createElement("fn-checkbox");
      fn_segment.insertBefore(checkbox, fn_segment.firstElementChild);

      return fn_segment;
    }

    /********************** Render Edit View ********************************/

    /**
      * Renders the edit view for the given segment
      *
      * @param {object HTMLElement} fn_segment
      * @param {object} segment
      */
    this.renderEditSegment = function(fn_segment, segment) {
      var fn_segment_edit = this.querySelector("fn-segment-edit");
      var _this = this;

      this.changeView("fn-segment-edit");
      this.initSegmentEdit();

      fn_segment_edit.querySelector("input[data-segment-name]").value = segment.name;

      //set option rules
      segment.rules.forEach(function(rule) {
        var option = fn_segment_edit.querySelector(
          "fn-segment-option[data-key='" + rule.field + "']");
        var segment_options = option.querySelectorAll('[data-segment-option]');

        option.querySelector("fn-checkbox").setAttribute('data-active', 'active');

        for (var i = 0; i < segment_options.length; i++) {
          //set rule option
          if (segment_options[i].hasAttribute('data-rule-opt')) {
            segment_options[i].setValue([rule.opt]);
            continue;
          }

          //set rule values
          segment_options[i].setValue(rule.values);
        }
      });


      fn_segment_edit.querySelector("[data-action='replace-segment']")
        .onclick = function(e) {

          e.stopPropagation();
          var edited_segment = _this.getSegmentSelection(fn_segment_edit);
          _this.removeErrorMessages();

          if (_this.validateSegment(edited_segment, false)) {
            _this.editSegment(segment.name, edited_segment);
            _this.fireEditSegmentEvent(segment, edited_segment);
            _this.changeView("fn-segment-flyout", false);
          }
        }
    };


    /**
      * Copies the segment options elements
      */
    this.initSegmentEdit = function() {
      var fn_segment_edit = this.querySelector("fn-segment-edit");
      var fn_segment_edit_options = fn_segment_edit.querySelector("fn-segment-options");
      var tpl = this.querySelector("template[name='fn-segment-select");
      var fn_segment_options = tpl.content.querySelector("fn-segment-select fn-segment-options");

      fn_segment_edit_options.innerHTML = fn_segment_options.innerHTML;
      fn_segment_edit.setAttribute('data-resolved', 'resolved');

      if (typeof this.customOptionHandling === 'function') {
        this.customOptionHandling(fn_segment_edit_options);
      }

      if (fn_segment_edit_options.querySelector("fn-menu")) {
        this.handleGroupMenu(fn_segment_edit_options);
      }
    };

    /************************** Render Preview ******************************/

    this.renderPreviewValues = function(segments) {
      var segments = segments;

      if (!segments) {
        var segments = JSON.parse(this.getAttribute('data-segments'));
      }

      var field = this.querySelector("fn-segment-editor-field-values");
      field.innerHTML = "";

      var field_text = document.createElement("fn-segment-field-text");
      field_text.innerHTML = "Segments (" + segments.length + ")";
      field.appendChild(field_text);

      for (var i = 0; i < segments.length; i++) {
        if (segments[i].color) {
          var circle = document.createElement("fn-segment-circle");
          circle.style.backgroundColor = segments[i].color;
          field.appendChild(circle);
        }
      }
    };

    /*********************** Visibility & Views *******************************/


    this.showFlyout = function() {
      Fnord.closeOpenItems();
      this.renderSegments();
      this.changeView("fn-segment-flyout", false);
      this.setAttribute('data-active', 'active');

      var flyout = this.querySelector("fn-segment-flyout");
      flyout.onclick = function(e) {
        e.stopPropagation();
      }
    }

    this.closeFlyout = function() {
      var flyout = this.querySelector("fn-segment-flyout");

      if (flyout.classList.contains("segment-active")) {
        flyout.classList.remove("segment-active");
        this.removeAttribute('data-active');
      }
    }


    /**
      * Copies the segment select template into the actual element
      */
    this.showSegmentSelect = function() {
      var tpl = this.querySelector("template[name='fn-segment-select']");
      var segment_tpl = tpl.content.querySelector("fn-segment-select");
      var segment_select = this.querySelector("fn-segment-select");
      var _this = this;
      segment_select.innerHTML = segment_tpl.innerHTML;

      this.changeView("fn-segment-select");
      this.removeErrorMessages();

      var tooltips = segment_select.querySelectorAll("fn-tooltip");
      for (var i = 0; i < tooltips.length; i++) {
        var help = tooltips[i].getAttribute('data-help');
        var elem = segment_select.querySelector("[data-help='" + help + "']");
        if (elem) {
          tooltips[i].init(elem);
          tooltips[i].getTopValue = _this.getTooltipTopValue.bind(_this);
          tooltips[i].getLeftValue = _this.getTooltipLeftValue.bind(_this);
        }
      }

      if (typeof this.customOptionHandling === 'function') {
        this.customOptionHandling(segment_select);
      }

      segment_select.querySelector("[data-action='save-segment']")
        .onclick = function(e) {
          e.stopPropagation();
          _this.onSaveSegment();
      }

      segment_select.querySelector("[data-action='cancel-segment']")
        .onclick = function(e) {
          e.stopPropagation();
          _this.changeView("fn-segment-recent", true);
      }

      if (segment_select.querySelector("fn-menu")) {
        this.handleGroupMenu(segment_select.querySelector("fn-segment-options"));
      }
    };


    this.renderRecentSegments = function(segments) {
      var _this = this;
      var fn_segment_recent = this.querySelector("fn-segment-recent");
      var fn_segments = fn_segment_recent.querySelector("fn-segments");
      var selection = [];

      fn_segments.innerHTML = "";

      if (segments.length == 0) {
        var tpl = this.querySelector("template[name='fn-segments-empty']");
        var segments_empty = tpl.content.querySelector("fn-segments-empty");
        fn_segments.innerHTML = (segments_empty.innerHTML);

        fn_segments.querySelector('.segment-link').onclick = function() {
           _this.showSegmentSelect();
        };
      }

      segments.forEach(function(segment) {
        var fn_segment = _this.createRecentSegment(segment);
        fn_segments.appendChild(fn_segment);

        var checkbox = fn_segment.querySelector("fn-checkbox");
        checkbox.addEventListener('fn-checkbox-select', function() {
          fn_segment.classList.add('segment-selected');
          selection.push(segment);
        }, false);

        checkbox.addEventListener('fn-checkbox-unselect', function() {
          fn_segment.classList.remove('segment-selected');
          selection.splice(selection.indexOf(segment), 1);
        }, false);
      });

      fn_segment_recent.querySelector("fn-loader")
        .removeAttribute('data-loading');

      fn_segment_recent.querySelector("fn-button[data-action='delete-selected']")
        .addEventListener('click', function() {
          _this.fireRemoveRecentEvent(selection);
          _this.loadRecentSegments(function(segments) {
            _this.renderRecentSegments(segments);
          });
        });

      fn_segment_recent.querySelector("fn-button[data-action='add-selected']")
        .addEventListener('click', function() {
          var segments = JSON.parse(_this.getAttribute('data-segments'));
          segments = segments.concat(selection);
          _this.setAttribute('data-segments', JSON.stringify(segments));
          _this.fireAddRecentEvent(selection);
        });
    };

    this.showRecentSegmentsLoader = function() {
      this.querySelector("fn-loader[name='recent_segments']")
        .setAttribute('data-loading', 'loading');
      this.changeView('fn-segment-recent');
    }



    this.changeView = function(selector, modalView) {
      var modal = this.querySelector("fn-modal");
      if (modalView == false) {
        modal.close();
      } else {
        modal.show();
      }

      if (!selector) {
        return;
      }

      var view = this.querySelector(selector);
      var active_view = this.querySelector(".segment-active");

      if (active_view) {
        active_view.classList.remove("segment-active");
      }

      view.classList.add("segment-active");

      if (selector == 'fn-segment-flyout') {
        var field = this.querySelector("fn-segment-editor-field");
        view.style.marginLeft =
          (view.offsetWidth / 2 - field.offsetWidth / 2) * -1 + "px";
      }
    };


    this.handleViewVisibility = function() {
      var add_btn = this.querySelector("[data-action='add-segment']");
      var cancel_btns = this.querySelectorAll("[data-action='cancel-segment']");
      var select_btn = this.querySelector("[data-action='segment-select']");
      var _this = this;

      add_btn.onclick = function(e) {
        e.stopPropagation();
        _this.showRecentSegmentsLoader();
        _this.loadRecentSegments(function(segments) {
          _this.renderRecentSegments(segments);
        });
      }

      select_btn.onclick = function(e) {
        e.stopPropagation();
        _this.showSegmentSelect();
      }

      for (var i = 0; i < cancel_btns.length; i++) {
        cancel_btns[i].onclick = function(e) {
          e.stopPropagation();
          _this.changeView("fn-segment-flyout", false);
        }
      }
    };

    /*************************** Tooltips **********************************/

    this.getTooltipLeftValue = function(elem) {
      var elem_left = elem.getBoundingClientRect().left;
      var modal = this.querySelector("fn-modal").getBoundingClientRect();

      return elem_left - modal.left - elem.offsetWidth ;
    };

    this.getTooltipTopValue = function(elem) {
      var fn_segment = elem.parentElement;
      var header = this.querySelector(".segment-active fn-segment-header");
      var elem_top = elem.getBoundingClientRect().top;
      var padding = window.getComputedStyle(fn_segment, null)
        .getPropertyValue('padding-top');
      var modal = this.querySelector("fn-modal").getBoundingClientRect();


      return (elem_top - header.offsetHeight +
        (parseInt(padding.substr(0, padding.length - 2), 10)) * 2
        - elem.offsetHeight * 1.8 - modal.top);
    };


    /*************************** Events ************************************/

    this.observeRemovableSegment = function(icon, segment_name) {
      var _this = this;
      var tooltip = this.querySelector(
        "fn-segment-flyout fn-tooltip[data-name='remove']");

      tooltip.init(icon);

      icon.onclick = function(e) {
        e.stopPropagation();
        _this.removeSegment(segment_name);
        _this.fireRemoveSegmentEvent(segment_name);
      }
    };

    this.observeEditableSegment = function(fn_segment, segment) {
      var _this = this;

      fn_segment.addEventListener('click', function(e) {
        e.stopPropagation();
        _this.renderEditSegment(fn_segment, segment);
      }, false);
    };


    this.fireRemoveRecentEvent = function(segments) {
      var ev = new CustomEvent('fn-segment-recent-remove', {
        'detail' : {'segments' : JSON.stringify(segments)},
        'bubbles': true,
        'cancelable' : true
      });

      this.dispatchEvent(ev);
    };

    this.fireAddRecentEvent = function(segments) {
      var ev = new CustomEvent('fn-segment-recent-add', {
        'detail' : {'segments' : JSON.stringify(segments)},
        'bubbles': true,
        'cancelable' : true
      });

      this.dispatchEvent(ev);

      this.fireSegmentsChangedEvent();
    }

    this.fireNewSegmentEvent = function(segment) {
      var ev = new CustomEvent('fn-segment-new', {
        'detail' : {'segment' : JSON.stringify(segment)},
        'bubbles': true,
        'cancelable' : true
      });

      this.dispatchEvent(ev);

      this.fireSegmentsChangedEvent();
    };


    this.fireRemoveSegmentEvent = function(name) {
      var ev = new CustomEvent('fn-segment-remove', {
        'detail' : {'segment_name' : name},
        'bubbles': true,
        'cancelable' : true
      });

      this.dispatchEvent(ev);
      this.fireSegmentsChangedEvent();
    };


    this.fireEditSegmentEvent = function(old_segment, new_segment) {
      var ev = new CustomEvent('fn-segment-edit', {
        'detail' : {
          'old_segment' : JSON.stringify(old_segment),
          'new_segment' : JSON.stringify(new_segment)
        },
        'bubbles': true,
        'cancelable' : true
      });

      this.dispatchEvent(ev);
      this.fireSegmentsChangedEvent();
    };

    this.fireSegmentsChangedEvent = function() {
      var ev = new CustomEvent('fn-segment-change', {
        'bubbles' : true,
        'cancelable' : true
      });

      this.dispatchEvent(ev);
    };
  };

  window.addEventListener('fn-ready', function() {
    Fnord.registerComponent('fn-segment-editor', SegmentEditor);
  }, false);
</script>
